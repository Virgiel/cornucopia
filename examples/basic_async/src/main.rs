#![feature(generic_associated_types)]

// Take a look at the generated `cornucopia.rs` file if you want to
// see what it looks like under the hood.
mod cornucopia;

use crate::cornucopia::{
    queries::{
        module_1::insert_book,
        module_2::{
            author_name_by_id, author_name_starting_with, authors, books, select_translations,
            select_where_custom_type, AuthorNameStartingWithParams,
        },
    },
    types::public::SpongebobCharacter,
};
use cornucopia_async::Params;
use deadpool_postgres::{Config, Runtime};
use tokio_postgres::NoTls;

#[tokio::main]
pub async fn main() {
    // Connection pool configuration
    // Please look at `tokio_postgres` and `deadpool_postgres` for details.
    let mut cfg = Config::new();
    cfg.user = Some(String::from("postgres"));
    cfg.password = Some(String::from("postgres"));
    cfg.host = Some(String::from("127.0.0.1"));
    cfg.port = Some(5435);
    cfg.dbname = Some(String::from("postgres"));
    let pool = cfg.create_pool(Some(Runtime::Tokio1), NoTls).unwrap();
    let mut client = pool.get().await.unwrap();

    // Queries accept regular clients.
    // The `all` method returns all rows in a `Vec`
    println!("{:?}", authors().bind(&client).all().await.unwrap());

    {
        // Queries also accept transactions
        let transaction = client.transaction().await.unwrap();

        // Insert a book
        // Note that queries with a void return type (such as regular inserts)
        // don't need to call `all`, they are executed as soon as you `bind` them.
        insert_book()
            .bind(&transaction, &"The Great Gatsby")
            .await
            .unwrap();

        // You can use a map to transform rows ergonomically.
        let uppercase_books = books()
            .bind(&transaction)
            .map(|b| b.to_uppercase())
            .all()
            .await
            .unwrap();
        println!("{uppercase_books:?}");

        // Don't forget to `.commit()` the transaction when you're done!
        // Otherwise, it will be rolled back without further effect.
        transaction.commit().await.unwrap();
    }

    // Using `opt` returns an optional row (zero or one).
    // Any other number of rows will return an error.
    println!(
        "{:?}",
        author_name_by_id().bind(&client, &0).opt().await.unwrap()
    );

    // Using named structs as parameters and rows can be more convenient
    // and less error-prone, for example when a query has a lot of parameters.
    // This query doesn't benefit much, but is still shown for demonstration purposes.
    // ! Note: To use this feature you need to:
    // ! 1. Have a struct generated for your params (see the `type annotations` section of the book
    // !    and the `queries/module_2.sql` file to see how this particular type was declared).
    // ! 2. Import the `Params` trait.
    println!(
        "{:?}",
        author_name_starting_with()
            .params(&client, &AuthorNameStartingWithParams { start_str: "Jo" })
            .all()
            .await
            .unwrap()
    );

    // Custom PostgreSQL types from your queries also work!
    // This includes domains, composites and enums.
    // They will be automatically generated by Cornucopia.
    // You can use them as bind parameters (as shown here)
    // or receive them in returned rows.
    println!(
        "{:?}",
        select_where_custom_type()
            .bind(&client, &SpongebobCharacter::Patrick)
            .one()
            .await
            .unwrap()
    );

    // Cornucopia also supports PostgreSQL arrays, which you
    // can use as bind parameters or in returned rows.
    println!(
        "{:?}",
        select_translations()
            .bind(&client)
            .map(|row| format!("{}: {:?}", row.title, row.translations))
            .all()
            .await
            .unwrap()
    );
}
